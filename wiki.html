<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wiki</title>
  <style>
*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/*! tailwindcss v3.4.19 | MIT License | https://tailwindcss.com*/*,:after,:before{box-sizing:border-box;border:0 solid #e5e7eb}:after,:before{--tw-content:""}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}body{margin:0;font-family:IBM Plex Sans,Segoe UI,sans-serif;background:radial-gradient(circle at top left,color-mix(in srgb,var(--bg) 76%,#8ad8d1) 0,var(--bg) 42%,var(--bg) 100%);color:var(--text)}button,input,textarea{font:inherit}.wk-app{min-height:100vh}.wk-header{display:flex;align-items:center;justify-content:space-between;gap:1rem;border-bottom-width:1px;padding:1rem 1.25rem;border-color:var(--line);background:color-mix(in srgb,var(--panel) 94%,#fff);box-shadow:var(--shadow)}.wk-header h1{margin:0;font-size:1.5rem;line-height:2rem;font-weight:600}.wk-header p{margin:0;font-size:.875rem;line-height:1.25rem;color:var(--muted)}.wk-header-actions{display:flex;flex-wrap:wrap;align-items:center;justify-content:flex-end;gap:.5rem}.wk-main{display:grid;gap:1rem;padding:1rem;grid-template-columns:320px 1fr 420px;min-height:calc(100vh - 96px)}.wk-panel{border-radius:.75rem;border-width:1px;padding:.75rem;border-color:var(--line);background:color-mix(in srgb,var(--panel) 97%,#fff);box-shadow:var(--shadow);display:flex;flex-direction:column;min-height:0}.wk-panel h2{margin:0;font-size:.875rem;line-height:1.25rem;text-transform:uppercase;letter-spacing:.025em;color:var(--muted)}.wk-panel-head{margin-bottom:.75rem;display:flex;align-items:center;justify-content:space-between;gap:.5rem}.wk-btn,.wk-icon-btn,.wk-link-btn{cursor:pointer;border-radius:.375rem;border-width:1px;border-color:color-mix(in srgb,var(--accent) 45%,var(--line));background:color-mix(in srgb,var(--accent) 12%,var(--panel));color:var(--text)}.wk-btn{padding:.375rem .75rem;font-size:.875rem;line-height:1.25rem}.wk-btn-muted{border-color:var(--line);background:color-mix(in srgb,var(--panel) 90%,#f8fafc)}.wk-btn-danger{border-color:color-mix(in srgb,var(--danger) 48%,var(--line));background:color-mix(in srgb,var(--danger) 16%,var(--panel))}.wk-icon-btn{height:2.25rem;width:2.25rem;font-size:1rem;line-height:1.5rem}.wk-file-btn input{display:none}.wk-controls{margin-bottom:.75rem;display:grid;gap:.5rem;grid-template-columns:1fr auto}.wk-controls input,.wk-form input,.wk-form textarea{width:100%;border-radius:.375rem;border-width:1px;padding:.5rem .75rem;font-size:.875rem;line-height:1.25rem;border-color:var(--line);background:color-mix(in srgb,var(--panel) 92%,#f8fafc);color:var(--text)}.wk-filter-block{margin-bottom:.75rem;border-radius:.5rem;border-width:1px;padding:.5rem;border-color:var(--line);background:color-mix(in srgb,var(--panel) 90%,#f8fafc)}.wk-filter-row{margin-bottom:.5rem;display:flex;align-items:center;justify-content:space-between}.wk-filter-row label{text-transform:uppercase;letter-spacing:.025em;color:var(--muted)}.wk-filter-row label,.wk-link-btn{font-size:.75rem;line-height:1rem}.wk-link-btn{padding:.25rem .5rem;border-color:transparent;background:transparent;color:var(--accent)}.wk-clusters,.wk-tags{display:flex;flex-wrap:wrap;gap:.5rem}.wk-tag{cursor:pointer;border-radius:9999px;border-width:1px;padding:.25rem .625rem;font-size:.75rem;line-height:1rem;border-color:var(--line);background:color-mix(in srgb,var(--panel) 88%,#f8fafc);color:var(--text)}.wk-tag.active{border-color:var(--accent);background:color-mix(in srgb,var(--accent) 20%,var(--panel))}.wk-tag.\!active{border-color:var(--accent)!important;background:color-mix(in srgb,var(--accent) 20%,var(--panel))!important}.wk-check{margin-top:.5rem;display:flex;align-items:center;gap:.5rem;font-size:.75rem;line-height:1rem;color:var(--muted)}.wk-list{overflow:auto;padding-right:.25rem;display:flex;flex-direction:column;gap:8px}.wk-item{cursor:pointer;border-radius:.5rem;border-width:1px;padding:.5rem;border-color:var(--line);background:color-mix(in srgb,var(--panel) 93%,#f8fafc)}.wk-item.active{border-color:var(--accent);background:color-mix(in srgb,var(--accent) 18%,var(--panel))}.wk-item.\!active{border-color:var(--accent)!important;background:color-mix(in srgb,var(--accent) 18%,var(--panel))!important}.wk-item h3{margin:0;font-size:.875rem;line-height:1.25rem;font-weight:600}.wk-item p{margin:.25rem 0 0;font-size:.75rem;line-height:1rem;color:var(--muted);display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}.wk-editor-actions,.wk-graph-actions{display:flex;gap:.5rem}.wk-clusters{margin-bottom:.5rem}.wk-cluster{border-radius:.375rem;border-width:1px;padding:.25rem .5rem;font-size:.75rem;line-height:1rem;border-color:var(--line);background:color-mix(in srgb,var(--panel) 89%,#f8fafc)}.wk-graph-canvas{position:relative;overflow:hidden;border-radius:.5rem;border-width:1px;border-color:var(--line);min-height:0;flex:1;background:linear-gradient(0deg,color-mix(in srgb,var(--line) 60%,transparent) 1px,transparent 1px) 0 0 /28px 28px,linear-gradient(90deg,color-mix(in srgb,var(--line) 60%,transparent) 1px,transparent 1px) 0 0 /28px 28px,color-mix(in srgb,var(--panel) 94%,#f8fafc);cursor:grab}.wk-graph-canvas.grabbing{cursor:grabbing}.wk-graph-viewport{position:absolute;inset:0;transform-origin:0 0}.wk-graph-lines{position:absolute;inset:0;overflow:visible}.wk-graph-lines path{fill:none;stroke:color-mix(in srgb,var(--text) 54%,var(--line));stroke-width:1.6}.wk-graph-lines path.dangling{stroke-dasharray:4 4;stroke:color-mix(in srgb,var(--danger) 68%,var(--line))}.wk-graph-lines path.highlight{stroke:var(--accent);stroke-width:2.3}.wk-graph-node{position:absolute;width:170px;min-height:50px;border-radius:10px;border:1px solid var(--line);background:color-mix(in srgb,var(--panel) 95%,#f8fafc);padding:8px;box-shadow:var(--shadow);cursor:pointer;-webkit-user-select:none;-moz-user-select:none;user-select:none}.wk-graph-node.active{border-color:var(--accent);box-shadow:0 0 0 2px color-mix(in srgb,var(--accent) 26%,transparent),var(--shadow)}.wk-graph-node.\!active{border-color:var(--accent)!important;box-shadow:0 0 0 2px color-mix(in srgb,var(--accent) 26%,transparent),var(--shadow)!important}.wk-graph-node .title{font-size:13px;font-weight:600;line-height:1.2;margin:0 0 6px;word-break:break-word}.wk-graph-node .\!title{font-size:13px!important;font-weight:600!important;line-height:1.2!important;margin:0 0 6px!important;word-break:break-word!important}.wk-graph-node .meta{font-size:11px;color:var(--muted);display:flex;flex-wrap:wrap;gap:4px}.wk-badge{border-radius:.25rem;border-width:1px;padding:.125rem .375rem;border-color:var(--line);background:color-mix(in srgb,var(--panel) 86%,#f8fafc)}.wk-form{display:grid;gap:.5rem}.wk-form textarea{resize:vertical;min-height:170px}.wk-preview-wrap{margin-top:.75rem;min-height:0}.wk-preview-wrap h3{margin-top:0;margin-bottom:.5rem;font-size:.75rem;line-height:1rem;text-transform:uppercase;letter-spacing:.025em;color:var(--muted)}.wk-backlinks,.wk-preview{overflow:auto;border-radius:.5rem;border-width:1px;padding:.75rem;font-size:.875rem;line-height:1.25rem;border-color:var(--line);background:color-mix(in srgb,var(--panel) 91%,#f8fafc);max-height:180px}.wk-preview p{margin:0 0 10px;line-height:1.5}.wk-preview pre{margin:0 0 10px;padding:8px;border-radius:8px;overflow-x:auto;background:color-mix(in srgb,var(--panel) 76%,#000);color:#e2e8f0}.wk-preview code{padding:1px 4px;border-radius:4px;background:color-mix(in srgb,var(--panel) 80%,#94a3b8)}.wk-wikilink{background:transparent}.wk-backlinks button,.wk-wikilink{cursor:pointer;border-width:0;padding:0;text-decoration-line:underline;color:var(--accent)}.wk-backlinks button{background-color:transparent}.wk-empty{font-size:.875rem;line-height:1.25rem;color:var(--muted)}.wk-dialog{border:1px solid var(--line);border-radius:12px;background:var(--panel);color:var(--text);padding:0;width:min(420px,92vw)}.wk-dialog::backdrop{background:rgba(15,23,42,.35)}.wk-dialog-form{padding:16px}.wk-dialog-form h3{margin:0 0 8px}.wk-dialog-form p{margin:0;color:var(--muted)}.wk-dialog-actions{margin-top:1rem;display:flex;justify-content:flex-end;gap:.5rem}.wk-toast{position:fixed;bottom:1rem;right:1rem;border-radius:.5rem;border-width:1px;padding:.5rem .75rem;font-size:.875rem;line-height:1.25rem;border-color:color-mix(in srgb,var(--accent) 48%,var(--line));background:color-mix(in srgb,var(--accent) 18%,var(--panel));color:var(--text);box-shadow:var(--shadow);z-index:50}.hidden,.wk-mobile-tabs{display:none}@media (max-width:1160px){.wk-main{grid-template-columns:280px 1fr;grid-template-areas:"list graph" "editor editor"}.wk-list-panel{grid-area:list}.wk-graph-panel{grid-area:graph;min-height:460px}.wk-editor-panel{grid-area:editor}}@media (max-width:860px){.wk-mobile-tabs{display:flex;gap:.5rem;padding-left:1rem;padding-right:1rem;padding-top:.75rem}.wk-mobile-tabs button{flex:1 1 0%;border-radius:.375rem;border-width:1px;padding-top:.5rem;padding-bottom:.5rem;font-size:.875rem;line-height:1.25rem;border-color:var(--line);background:color-mix(in srgb,var(--panel) 90%,#f8fafc);color:var(--text)}.wk-mobile-tabs button.active{border-color:var(--accent);background:color-mix(in srgb,var(--accent) 18%,var(--panel))}.wk-main{grid-template-columns:1fr;min-height:auto}.wk-panel[data-pane]{display:none}.wk-panel[data-pane].active{display:flex;min-height:72vh}.wk-header{flex-direction:column;align-items:flex-start}.wk-header-actions{width:100%;justify-content:flex-start}.wk-controls{grid-template-columns:1fr}.wk-mobile-tabs button.\!active{border-color:var(--accent)!important;background:color-mix(in srgb,var(--accent) 18%,var(--panel))!important}.wk-panel[data-pane].\!active{display:flex!important;min-height:72vh!important}}.hidden{display:none}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.resize{resize:both}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}:root{--bg:#edf2f7;--panel:#fff;--text:#172135;--muted:#5f6f85;--line:#cfdae7;--accent:#0f766e;--accent-soft:#d7f1ef;--danger:#b42318;--shadow:0 12px 24px -20px rgba(23,33,53,.45)}[data-theme=dark]{--bg:#0d1320;--panel:#141c2d;--text:#e6edf8;--muted:#9badc6;--line:#2a3752;--accent:#31b3a8;--accent-soft:#1f313d;--danger:#f97066;--shadow:0 18px 32px -22px rgba(0,0,0,.7)}
  </style>
</head>

<body>
  <div class="wk-app">
    <header class="wk-header">
      <div>
        <h1>Local Knowledge Graph</h1>
        <p>Markdown notes + wiki links + graph</p>
      </div>
      <div class="wk-header-actions">
        <button id="export-btn" class="wk-btn">Export JSON</button>
        <label class="wk-btn wk-file-btn">
          Import JSON
          <input id="import-input" type="file" accept="application/json" hidden>
        </label>
        <button id="dashboard-btn" class="wk-icon-btn" aria-label="Go to dashboard" title="Go to dashboard">⌂</button>
        <button id="theme-toggle" class="wk-icon-btn" aria-label="Switch theme" title="Switch theme"></button>
      </div>
    </header>

    <div class="wk-mobile-tabs" id="mobile-tabs">
      <button data-tab="list" class="active">List</button>
      <button data-tab="graph">Graph</button>
      <button data-tab="editor">Editor</button>
    </div>

    <main class="wk-main">
      <section class="wk-panel wk-list-panel" data-pane="list">
        <div class="wk-panel-head">
          <h2>Notes</h2>
          <button id="new-note-btn" class="wk-btn">New</button>
        </div>

        <div class="wk-controls">
          <input id="search-input" type="text" placeholder="Search notes, content, tags">
          <button id="clear-search-btn" class="wk-btn wk-btn-muted">Clear</button>
        </div>

        <div class="wk-filter-block">
          <div class="wk-filter-row">
            <label>Tags (match any)</label>
            <button id="clear-tags-btn" class="wk-link-btn">Clear tags</button>
          </div>
          <div id="tag-filter" class="wk-tags"></div>
          <label class="wk-check">
            <input id="unlinked-only" type="checkbox">
            Show only unlinked notes
          </label>
        </div>

        <div id="note-list" class="wk-list"></div>
        <p id="empty-list" class="wk-empty hidden">No notes found.</p>
      </section>

      <section class="wk-panel wk-graph-panel" data-pane="graph">
        <div class="wk-panel-head">
          <h2>Graph</h2>
          <div class="wk-graph-actions">
            <button id="reset-layout-btn" class="wk-btn wk-btn-muted">Reset layout</button>
            <button id="fit-graph-btn" class="wk-btn wk-btn-muted">Center</button>
          </div>
        </div>

        <div id="cluster-legend" class="wk-clusters"></div>

        <div id="graph-canvas" class="wk-graph-canvas">
          <div id="graph-viewport" class="wk-graph-viewport">
            <svg id="graph-lines" class="wk-graph-lines" xmlns="http://www.w3.org/2000/svg"></svg>
            <div id="graph-nodes" class="wk-graph-nodes"></div>
          </div>
        </div>
      </section>

      <section class="wk-panel wk-editor-panel" data-pane="editor">
        <div class="wk-panel-head">
          <h2 id="editor-title">New Note</h2>
          <div class="wk-editor-actions">
            <button id="save-note-btn" class="wk-btn">Save</button>
            <button id="delete-note-btn" class="wk-btn wk-btn-danger wk-btn-muted">Delete</button>
          </div>
        </div>

        <form id="note-form" class="wk-form">
          <input id="note-title" type="text" placeholder="Title" required>
          <input id="note-tags" type="text" placeholder="Tags (comma separated)">
          <textarea id="note-body" rows="12" placeholder="Write markdown. Use [[Note Title]] to link."></textarea>
        </form>

        <div class="wk-preview-wrap">
          <h3>Preview</h3>
          <div id="note-preview" class="wk-preview"></div>
        </div>

        <div class="wk-preview-wrap">
          <h3>Backlinks</h3>
          <div id="backlinks" class="wk-backlinks"></div>
        </div>
      </section>
    </main>
  </div>

  <dialog id="confirm-dialog" class="wk-dialog">
    <form method="dialog" class="wk-dialog-form">
      <h3 id="confirm-title">Confirm</h3>
      <p id="confirm-message"></p>
      <div class="wk-dialog-actions">
        <button value="cancel" class="wk-btn wk-btn-muted">Cancel</button>
        <button value="ok" class="wk-btn wk-btn-danger">Continue</button>
      </div>
    </form>
  </dialog>

  <div id="toast" class="wk-toast hidden"></div>

  <script>
(function () {
  const KEY = 'spa-theme';
  const VALID = new Set(['dark', 'light']);
  let initialized = false;

  function normalize(mode) {
    return VALID.has(mode) ? mode : null;
  }

  function readStored() {
    try {
      return normalize(localStorage.getItem(KEY));
    } catch {
      return null;
    }
  }

  function apply(mode) {
    document.documentElement.dataset.theme = mode;
    document.documentElement.style.colorScheme = mode;
  }

  function emit(mode) {
    window.dispatchEvent(new CustomEvent('themechange', { detail: { mode } }));
  }

  function get() {
    return normalize(document.documentElement.dataset.theme) || 'dark';
  }

  function set(mode, persist = true) {
    const normalized = normalize(mode) || 'dark';
    apply(normalized);
    if (persist) {
      try {
        localStorage.setItem(KEY, normalized);
      } catch {
        // ignore storage failures
      }
    }
    emit(normalized);
    return normalized;
  }

  function init(options = {}) {
    const fallback = normalize(options.defaultMode) || 'dark';
    const stored = readStored();
    const mode = stored || fallback;
    apply(mode);
    if (!stored) {
      try {
        localStorage.setItem(KEY, mode);
      } catch {
        // ignore storage failures
      }
    }
    if (!initialized) {
      emit(mode);
      initialized = true;
    }
    return mode;
  }

  function toggle() {
    return set(get() === 'dark' ? 'light' : 'dark');
  }

  function mountToggle(button, options = {}) {
    if (!button) return;

    const darkIcon = options.darkIcon || '☀';
    const lightIcon = options.lightIcon || '☾';

    const sync = () => {
      const mode = get();
      const next = mode === 'dark' ? 'light' : 'dark';
      button.textContent = mode === 'dark' ? darkIcon : lightIcon;
      button.setAttribute('aria-label', `Switch to ${next} mode`);
      button.setAttribute('title', `Switch to ${next} mode`);
      button.dataset.mode = mode;
    };

    button.addEventListener('click', () => toggle());
    window.addEventListener('themechange', sync);
    sync();
  }

  window.Theme = {
    init,
    get,
    set,
    toggle,
    mountToggle,
  };

  window.AppNav = {
    goDashboard() {
      window.location.href = 'dashboard.html';
    },
  };
})();
  </script>
  <script>
const DB_NAME = 'spas-wiki';
const DB_VERSION = 1;
const NOTES_STORE = 'notes';
const META_STORE = 'meta';
const META_UI_KEY = 'ui';
const META_POSITIONS_KEY = 'graphPositions';

const DEFAULT_UI = {
  query: '',
  selectedTags: [],
  unlinkedOnly: false,
  activeNoteId: null,
  creatingNew: false,
  mobileTab: 'list',
};

const state = {
  db: null,
  notes: [],
  positions: {},
  ui: { ...DEFAULT_UI },
  graph: {
    panX: 240,
    panY: 160,
    zoom: 1,
    draggingNodeId: null,
  },
  cache: {
    model: null,
    filteredIds: new Set(),
  },
};

const el = {
  noteList: document.getElementById('note-list'),
  emptyList: document.getElementById('empty-list'),
  search: document.getElementById('search-input'),
  clearSearchBtn: document.getElementById('clear-search-btn'),
  tagFilter: document.getElementById('tag-filter'),
  clearTagsBtn: document.getElementById('clear-tags-btn'),
  unlinkedOnly: document.getElementById('unlinked-only'),
  newNoteBtn: document.getElementById('new-note-btn'),
  resetLayoutBtn: document.getElementById('reset-layout-btn'),
  fitGraphBtn: document.getElementById('fit-graph-btn'),
  exportBtn: document.getElementById('export-btn'),
  importInput: document.getElementById('import-input'),
  clusterLegend: document.getElementById('cluster-legend'),
  graphCanvas: document.getElementById('graph-canvas'),
  graphViewport: document.getElementById('graph-viewport'),
  graphLines: document.getElementById('graph-lines'),
  graphNodes: document.getElementById('graph-nodes'),
  noteForm: document.getElementById('note-form'),
  editorTitle: document.getElementById('editor-title'),
  saveBtn: document.getElementById('save-note-btn'),
  deleteBtn: document.getElementById('delete-note-btn'),
  inputTitle: document.getElementById('note-title'),
  inputTags: document.getElementById('note-tags'),
  inputBody: document.getElementById('note-body'),
  preview: document.getElementById('note-preview'),
  backlinks: document.getElementById('backlinks'),
  dashboardBtn: document.getElementById('dashboard-btn'),
  themeToggle: document.getElementById('theme-toggle'),
  mobileTabs: document.getElementById('mobile-tabs'),
  confirmDialog: document.getElementById('confirm-dialog'),
  confirmTitle: document.getElementById('confirm-title'),
  confirmMessage: document.getElementById('confirm-message'),
  toast: document.getElementById('toast'),
};

let toastTimer = null;

function uid() {
  if (window.crypto && window.crypto.randomUUID) return window.crypto.randomUUID();
  return 'note_' + Math.random().toString(36).slice(2, 10);
}

function nowIso() {
  return new Date().toISOString();
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text || '';
  return div.innerHTML;
}

function normTitleKey(title) {
  return (title || '').trim().toLowerCase();
}

function parseTags(raw) {
  return [...new Set(
    (raw || '')
      .split(',')
      .map(tag => tag.trim().toLowerCase())
      .filter(Boolean)
  )];
}

function parseWikiLinks(markdown) {
  const out = [];
  const seen = new Set();
  const re = /\[\[([^\[\]]+)\]\]/g;
  let match;
  while ((match = re.exec(markdown || ''))) {
    const title = match[1].trim();
    if (!title) continue;
    const k = normTitleKey(title);
    if (seen.has(k)) continue;
    seen.add(k);
    out.push(title);
  }
  return out;
}

function tokenizeQuery(query) {
  return (query || '').toLowerCase().split(/\s+/).map(s => s.trim()).filter(Boolean);
}

function combinedSearchText(note) {
  return [note.title, note.body, (note.tags || []).join(' ')].join(' ').toLowerCase();
}

function hashCode(s) {
  let h = 0;
  for (let i = 0; i < s.length; i += 1) {
    h = (h * 31 + s.charCodeAt(i)) | 0;
  }
  return Math.abs(h);
}

function colorForTag(tag) {
  const palette = ['#14b8a6', '#22c55e', '#f59e0b', '#3b82f6', '#ef4444', '#8b5cf6', '#f97316', '#10b981'];
  return palette[hashCode(tag || 'untagged') % palette.length];
}

function preferredTag(note) {
  return note.tags && note.tags.length ? note.tags[0] : 'untagged';
}

function buildIndex(notes) {
  const titleToId = new Map();
  notes.forEach(note => {
    titleToId.set(normTitleKey(note.title), note.id);
  });

  const outgoingById = new Map();
  const incomingById = new Map();
  const danglingById = new Map();
  notes.forEach(note => {
    incomingById.set(note.id, new Set());
    outgoingById.set(note.id, []);
    danglingById.set(note.id, []);
  });

  notes.forEach(note => {
    const links = parseWikiLinks(note.body || '');
    const outgoing = [];
    links.forEach(title => {
      const resolved = titleToId.get(normTitleKey(title)) || null;
      outgoing.push({ title, targetId: resolved });
      if (resolved) {
        incomingById.get(resolved).add(note.id);
      } else {
        danglingById.get(note.id).push(title);
      }
    });
    outgoingById.set(note.id, outgoing);
  });

  return { titleToId, outgoingById, incomingById, danglingById };
}

function noteMatches(note, queryTokens, selectedTagsSet, index) {
  const queryOk = queryTokens.length === 0 || queryTokens.every(t => combinedSearchText(note).includes(t));
  const tagsOk = selectedTagsSet.size === 0 || (note.tags || []).some(t => selectedTagsSet.has(t));
  const linkCount = (index.outgoingById.get(note.id) || []).filter(l => l.targetId).length + (index.incomingById.get(note.id) || new Set()).size;
  const unlinkedOk = !state.ui.unlinkedOnly || linkCount === 0;
  return queryOk && tagsOk && unlinkedOk;
}

function buildGraphModel(notes) {
  const index = buildIndex(notes);
  const queryTokens = tokenizeQuery(state.ui.query);
  const selectedTagsSet = new Set(state.ui.selectedTags);

  const filtered = notes.filter(note => noteMatches(note, queryTokens, selectedTagsSet, index));
  const filteredIds = new Set(filtered.map(n => n.id));

  const edges = [];
  filtered.forEach(source => {
    const outgoing = index.outgoingById.get(source.id) || [];
    outgoing.forEach(link => {
      if (!link.targetId) {
        edges.push({ type: 'dangling', sourceId: source.id, title: link.title });
        return;
      }
      if (!filteredIds.has(link.targetId)) return;
      edges.push({ type: 'resolved', sourceId: source.id, targetId: link.targetId, title: link.title });
    });
  });

  const clusters = new Map();
  filtered.forEach(note => {
    const tag = preferredTag(note);
    if (!clusters.has(tag)) clusters.set(tag, { tag, count: 0, color: colorForTag(tag) });
    clusters.get(tag).count += 1;
  });

  return {
    index,
    filtered,
    filteredIds,
    edges,
    clusters: [...clusters.values()].sort((a, b) => b.count - a.count || a.tag.localeCompare(b.tag)),
  };
}

function defaultPosition(noteId, i, total) {
  const angle = (Math.PI * 2 * i) / Math.max(total, 1);
  const radius = 260 + (Math.floor(i / 16) * 140);
  const jitter = (hashCode(noteId) % 30) - 15;
  return {
    x: Math.round(Math.cos(angle) * radius + jitter),
    y: Math.round(Math.sin(angle) * radius - jitter),
  };
}

function ensurePositions(notes) {
  let changed = false;
  notes.forEach((note, i) => {
    if (!state.positions[note.id]) {
      state.positions[note.id] = defaultPosition(note.id, i, notes.length);
      changed = true;
    }
  });
  if (changed) persistMeta().catch(() => {});
}

function renderTags(model) {
  const allTags = new Set();
  state.notes.forEach(n => (n.tags || []).forEach(t => allTags.add(t)));
  const tags = [...allTags].sort((a, b) => a.localeCompare(b));

  el.tagFilter.innerHTML = '';
  tags.forEach(tag => {
    const btn = document.createElement('button');
    btn.className = 'wk-tag' + (state.ui.selectedTags.includes(tag) ? ' active' : '');
    btn.textContent = tag;
    btn.type = 'button';
    btn.style.borderColor = state.ui.selectedTags.includes(tag) ? colorForTag(tag) : '';
    btn.addEventListener('click', async () => {
      if (state.ui.selectedTags.includes(tag)) {
        state.ui.selectedTags = state.ui.selectedTags.filter(t => t !== tag);
      } else {
        state.ui.selectedTags = [...state.ui.selectedTags, tag];
      }
      await persistMeta();
      renderAll();
    });
    el.tagFilter.appendChild(btn);
  });

  el.clusterLegend.innerHTML = '';
  model.clusters.forEach(cluster => {
    const item = document.createElement('span');
    item.className = 'wk-cluster';
    item.style.borderColor = cluster.color;
    item.textContent = `${cluster.tag} (${cluster.count})`;
    el.clusterLegend.appendChild(item);
  });
}

function renderList(model) {
  const currentId = state.ui.activeNoteId;
  el.noteList.innerHTML = '';

  const sorted = [...model.filtered].sort((a, b) => {
    const ad = Date.parse(a.updatedAt || a.createdAt || nowIso());
    const bd = Date.parse(b.updatedAt || b.createdAt || nowIso());
    return bd - ad;
  });

  sorted.forEach(note => {
    const card = document.createElement('article');
    card.className = 'wk-item' + (note.id === currentId ? ' active' : '');
    const snippet = (note.body || '').replace(/\s+/g, ' ').trim();
    const links = parseWikiLinks(note.body || '').length;
    card.innerHTML = `
      <h3>${escapeHtml(note.title)}</h3>
      <p>${escapeHtml(snippet || 'Empty note')}</p>
      <p>${(note.tags || []).map(tag => `#${escapeHtml(tag)}`).join(' ')} ${links ? `· ${links} link${links > 1 ? 's' : ''}` : ''}</p>
    `;
    card.addEventListener('click', async () => {
      state.ui.activeNoteId = note.id;
      state.ui.creatingNew = false;
      await persistMeta();
      renderAll();
      focusPane('editor');
    });
    el.noteList.appendChild(card);
  });

  el.emptyList.classList.toggle('hidden', sorted.length > 0);
}

function getActiveNote() {
  return state.notes.find(n => n.id === state.ui.activeNoteId) || null;
}

function renderEditor(model) {
  const note = getActiveNote();
  if (!note) {
    el.editorTitle.textContent = 'New Note';
    el.deleteBtn.disabled = true;
    if (document.activeElement !== el.inputTitle && document.activeElement !== el.inputTags && document.activeElement !== el.inputBody) {
      el.inputTitle.value = '';
      el.inputTags.value = '';
      el.inputBody.value = '';
      renderPreview('');
      renderBacklinks([], model);
    }
    return;
  }

  el.editorTitle.textContent = note.title;
  el.deleteBtn.disabled = false;

  if (document.activeElement !== el.inputTitle) el.inputTitle.value = note.title;
  if (document.activeElement !== el.inputTags) el.inputTags.value = (note.tags || []).join(', ');
  if (document.activeElement !== el.inputBody) el.inputBody.value = note.body || '';

  renderPreview(note.body || '');
  const backlinkIds = [...(model.index.incomingById.get(note.id) || [])];
  renderBacklinks(backlinkIds, model);
}

function renderPreview(markdown) {
  el.preview.innerHTML = markdownToHtml(markdown || '');
}

function renderBacklinks(backlinkIds) {
  el.backlinks.innerHTML = '';
  if (!backlinkIds.length) {
    el.backlinks.textContent = 'No backlinks yet.';
    return;
  }

  backlinkIds
    .map(id => state.notes.find(n => n.id === id))
    .filter(Boolean)
    .sort((a, b) => a.title.localeCompare(b.title))
    .forEach(note => {
      const row = document.createElement('div');
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.textContent = note.title;
      btn.addEventListener('click', async () => {
        state.ui.activeNoteId = note.id;
        state.ui.creatingNew = false;
        await persistMeta();
        renderAll();
        focusPane('editor');
      });
      row.appendChild(btn);
      el.backlinks.appendChild(row);
    });
}

function updateGraphTransform() {
  el.graphViewport.style.transform = `translate(${state.graph.panX}px, ${state.graph.panY}px) scale(${state.graph.zoom})`;
}

function getNodeCenter(nodeId) {
  const p = state.positions[nodeId] || { x: 0, y: 0 };
  return { x: p.x + 85, y: p.y + 25 };
}

function edgePath(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const bend = Math.max(40, Math.min(130, Math.abs(dx) * 0.35));
  return `M${x1},${y1} C${x1 + bend},${y1} ${x2 - bend},${y2} ${x2},${y2}`;
}

function renderGraph(model) {
  ensurePositions(state.notes);
  updateGraphTransform();

  el.graphNodes.innerHTML = '';
  el.graphLines.innerHTML = '<defs><marker id="wk-arrow" markerWidth="10" markerHeight="8" refX="9" refY="4" orient="auto"><path d="M0,0 L10,4 L0,8 z" fill="currentColor"></path></marker></defs>';

  model.edges.forEach(edge => {
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    let x1;
    let y1;
    let x2;
    let y2;
    if (edge.type === 'resolved') {
      const source = getNodeCenter(edge.sourceId);
      const target = getNodeCenter(edge.targetId);
      x1 = source.x;
      y1 = source.y;
      x2 = target.x;
      y2 = target.y;
    } else {
      const source = getNodeCenter(edge.sourceId);
      const h = hashCode(edge.title || 'dangling');
      const angle = (h % 360) * (Math.PI / 180);
      x1 = source.x;
      y1 = source.y;
      x2 = source.x + Math.cos(angle) * 100;
      y2 = source.y + Math.sin(angle) * 70;
      path.classList.add('dangling');
    }

    path.setAttribute('d', edgePath(x1, y1, x2, y2));
    path.setAttribute('marker-end', 'url(#wk-arrow)');
    if (state.ui.activeNoteId && edge.sourceId === state.ui.activeNoteId) {
      path.classList.add('highlight');
    }
    el.graphLines.appendChild(path);
  });

  model.filtered.forEach(note => {
    const node = document.createElement('button');
    node.type = 'button';
    node.className = 'wk-graph-node' + (note.id === state.ui.activeNoteId ? ' active' : '');
    node.dataset.id = note.id;
    const pos = state.positions[note.id] || { x: 0, y: 0 };
    node.style.left = `${pos.x}px`;
    node.style.top = `${pos.y}px`;

    const tag = preferredTag(note);
    node.style.borderColor = colorForTag(tag);

    node.innerHTML = `
      <p class="title">${escapeHtml(note.title)}</p>
      <div class="meta">
        ${(note.tags || []).slice(0, 3).map(t => `<span class="wk-badge">#${escapeHtml(t)}</span>`).join('')}
      </div>
    `;

    node.addEventListener('click', async (event) => {
      if (state.graph.draggingNodeId) {
        event.preventDefault();
        return;
      }
      state.ui.activeNoteId = note.id;
      state.ui.creatingNew = false;
      await persistMeta();
      renderAll();
      focusPane('editor');
    });

    setupNodeDrag(node, note.id);
    el.graphNodes.appendChild(node);
  });
}

function setupNodeDrag(nodeEl, nodeId) {
  let startX = 0;
  let startY = 0;
  let startNodeX = 0;
  let startNodeY = 0;
  let moved = false;

  nodeEl.addEventListener('mousedown', (e) => {
    e.preventDefault();
    e.stopPropagation();
    moved = false;
    state.graph.draggingNodeId = nodeId;
    startX = e.clientX;
    startY = e.clientY;
    const p = state.positions[nodeId] || { x: 0, y: 0 };
    startNodeX = p.x;
    startNodeY = p.y;

    const onMove = (ev) => {
      const dx = (ev.clientX - startX) / state.graph.zoom;
      const dy = (ev.clientY - startY) / state.graph.zoom;
      if (Math.abs(dx) > 2 || Math.abs(dy) > 2) moved = true;
      state.positions[nodeId] = {
        x: Math.round(startNodeX + dx),
        y: Math.round(startNodeY + dy),
      };
      nodeEl.style.left = `${state.positions[nodeId].x}px`;
      nodeEl.style.top = `${state.positions[nodeId].y}px`;
      renderGraph(state.cache.model);
    };

    const onUp = async () => {
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
      state.graph.draggingNodeId = moved ? nodeId : null;
      await persistMeta();
      setTimeout(() => {
        state.graph.draggingNodeId = null;
      }, 0);
    };

    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  });
}

function setupGraphPanAndZoom() {
  let panning = false;
  let startX = 0;
  let startY = 0;
  let basePanX = 0;
  let basePanY = 0;

  el.graphCanvas.addEventListener('mousedown', (e) => {
    if (e.target !== el.graphCanvas && e.target !== el.graphLines && e.target !== el.graphViewport) return;
    panning = true;
    startX = e.clientX;
    startY = e.clientY;
    basePanX = state.graph.panX;
    basePanY = state.graph.panY;
    el.graphCanvas.classList.add('grabbing');
  });

  window.addEventListener('mousemove', (e) => {
    if (!panning) return;
    state.graph.panX = basePanX + (e.clientX - startX);
    state.graph.panY = basePanY + (e.clientY - startY);
    updateGraphTransform();
  });

  window.addEventListener('mouseup', () => {
    panning = false;
    el.graphCanvas.classList.remove('grabbing');
  });

  el.graphCanvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = el.graphCanvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const factor = e.deltaY > 0 ? 0.92 : 1.08;
    const nextZoom = Math.min(2.2, Math.max(0.28, state.graph.zoom * factor));

    state.graph.panX = mx - ((mx - state.graph.panX) * nextZoom) / state.graph.zoom;
    state.graph.panY = my - ((my - state.graph.panY) * nextZoom) / state.graph.zoom;
    state.graph.zoom = nextZoom;
    updateGraphTransform();
  }, { passive: false });
}

function focusGraphToVisible(model) {
  if (!model.filtered.length) return;
  const rect = el.graphCanvas.getBoundingClientRect();
  const xs = model.filtered.map(n => (state.positions[n.id]?.x || 0) + 85);
  const ys = model.filtered.map(n => (state.positions[n.id]?.y || 0) + 25);
  const cx = (Math.min(...xs) + Math.max(...xs)) / 2;
  const cy = (Math.min(...ys) + Math.max(...ys)) / 2;
  state.graph.panX = rect.width / 2 - cx * state.graph.zoom;
  state.graph.panY = rect.height / 2 - cy * state.graph.zoom;
  updateGraphTransform();
}

function ensureActiveNote(model) {
  if (!state.notes.length) {
    state.ui.activeNoteId = null;
    state.ui.creatingNew = false;
    return;
  }
  if (state.ui.creatingNew) {
    state.ui.activeNoteId = null;
    return;
  }
  if (state.ui.activeNoteId && state.notes.some(n => n.id === state.ui.activeNoteId)) {
    return;
  }
  state.ui.activeNoteId = model.filtered[0]?.id || state.notes[0].id;
}

function renderAll() {
  const model = buildGraphModel(state.notes);
  state.cache.model = model;
  state.cache.filteredIds = model.filteredIds;
  ensureActiveNote(model);
  renderTags(model);
  renderList(model);
  renderEditor(model);
  renderGraph(model);
  renderMobileTab();
}

function showToast(message, timeout = 2200) {
  el.toast.textContent = message;
  el.toast.classList.remove('hidden');
  if (toastTimer) clearTimeout(toastTimer);
  toastTimer = setTimeout(() => {
    el.toast.classList.add('hidden');
  }, timeout);
}

function openConfirm({ title, message }) {
  return new Promise(resolve => {
    if (!el.confirmDialog || !el.confirmDialog.showModal) {
      resolve(window.confirm(message));
      return;
    }
    el.confirmTitle.textContent = title;
    el.confirmMessage.textContent = message;
    el.confirmDialog.showModal();
    el.confirmDialog.addEventListener('close', () => {
      resolve(el.confirmDialog.returnValue === 'ok');
    }, { once: true });
  });
}

function markdownInline(raw) {
  let text = escapeHtml(raw || '');
  text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
  text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');
  text = text.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noreferrer">$1</a>');
  text = text.replace(/\[\[([^\[\]]+)\]\]/g, (_, title) => {
    const t = title.trim();
    return `<button class="wk-wikilink" data-open-title="${escapeHtml(t)}" type="button">${escapeHtml(t)}</button>`;
  });
  return text;
}

function markdownToHtml(md) {
  const lines = (md || '').replace(/\r/g, '').split('\n');
  const out = [];
  let inCode = false;
  let inList = false;

  lines.forEach(line => {
    if (line.startsWith('```')) {
      if (!inCode) {
        inCode = true;
        out.push('<pre><code>');
      } else {
        inCode = false;
        out.push('</code></pre>');
      }
      return;
    }

    if (inCode) {
      out.push(escapeHtml(line) + '\n');
      return;
    }

    const heading = line.match(/^(#{1,6})\s+(.*)$/);
    if (heading) {
      if (inList) {
        out.push('</ul>');
        inList = false;
      }
      const level = heading[1].length;
      out.push(`<h${level}>${markdownInline(heading[2])}</h${level}>`);
      return;
    }

    const bullet = line.match(/^[-*]\s+(.*)$/);
    if (bullet) {
      if (!inList) {
        inList = true;
        out.push('<ul>');
      }
      out.push(`<li>${markdownInline(bullet[1])}</li>`);
      return;
    }

    if (line.trim() === '') {
      if (inList) {
        out.push('</ul>');
        inList = false;
      }
      return;
    }

    if (inList) {
      out.push('</ul>');
      inList = false;
    }
    out.push(`<p>${markdownInline(line)}</p>`);
  });

  if (inList) out.push('</ul>');
  if (inCode) out.push('</code></pre>');

  return out.join('');
}

async function dbOpen() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(NOTES_STORE)) {
        db.createObjectStore(NOTES_STORE, { keyPath: 'id' });
      }
      if (!db.objectStoreNames.contains(META_STORE)) {
        db.createObjectStore(META_STORE, { keyPath: 'key' });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

function readAllNotes(db) {
  return new Promise((resolve, reject) => {
    const req = db.transaction(NOTES_STORE).objectStore(NOTES_STORE).getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}

function readMeta(db, key) {
  return new Promise((resolve, reject) => {
    const req = db.transaction(META_STORE).objectStore(META_STORE).get(key);
    req.onsuccess = () => resolve(req.result ? req.result.value : null);
    req.onerror = () => reject(req.error);
  });
}

function persistNotes(notes) {
  return new Promise((resolve, reject) => {
    const tx = state.db.transaction(NOTES_STORE, 'readwrite');
    const store = tx.objectStore(NOTES_STORE);
    store.clear();
    notes.forEach(note => store.put(note));
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

function persistMeta() {
  return new Promise((resolve, reject) => {
    const tx = state.db.transaction(META_STORE, 'readwrite');
    const store = tx.objectStore(META_STORE);
    store.put({ key: META_UI_KEY, value: state.ui });
    store.put({ key: META_POSITIONS_KEY, value: state.positions });
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

function validateUniqueTitle(title, existingId = null) {
  const key = normTitleKey(title);
  if (!key) return { ok: false, error: 'Title is required.' };
  const duplicate = state.notes.find(n => n.id !== existingId && normTitleKey(n.title) === key);
  if (duplicate) return { ok: false, error: 'A note with this title already exists.' };
  return { ok: true };
}

function replaceWikiTitleRefs(text, oldTitle, newTitle) {
  const escaped = oldTitle.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const re = new RegExp(`\\[\\[\\s*${escaped}\\s*\\]\\]`, 'g');
  return (text || '').replace(re, `[[${newTitle}]]`);
}

async function saveCurrentNote() {
  const active = getActiveNote();
  const title = el.inputTitle.value.trim();
  const body = el.inputBody.value;
  const tags = parseTags(el.inputTags.value);

  const check = validateUniqueTitle(title, active?.id || null);
  if (!check.ok) {
    showToast(check.error);
    return;
  }

  const ts = nowIso();
  if (!active) {
    const note = {
      id: uid(),
      title,
      body,
      tags,
      createdAt: ts,
      updatedAt: ts,
    };
    state.notes.unshift(note);
    state.ui.activeNoteId = note.id;
    state.ui.creatingNew = false;
    state.positions[note.id] = defaultPosition(note.id, state.notes.length, state.notes.length + 1);
  } else {
    const oldTitle = active.title;
    active.title = title;
    active.body = body;
    active.tags = tags;
    active.updatedAt = ts;

    if (normTitleKey(oldTitle) !== normTitleKey(title)) {
      state.notes.forEach(note => {
        if (note.id === active.id) return;
        const updated = replaceWikiTitleRefs(note.body, oldTitle, title);
        if (updated !== note.body) {
          note.body = updated;
          note.updatedAt = ts;
        }
      });
      showToast('Renamed and updated wiki links.');
    }
  }

  await persistNotes(state.notes);
  await persistMeta();
  renderAll();
  showToast('Saved.');
}

async function createNewNote() {
  state.ui.activeNoteId = null;
  state.ui.creatingNew = true;
  await persistMeta();
  el.inputTitle.value = '';
  el.inputTags.value = '';
  el.inputBody.value = '';
  renderPreview('');
  renderAll();
  el.inputTitle.focus();
  focusPane('editor');
}

async function deleteActiveNote() {
  const note = getActiveNote();
  if (!note) return;
  const ok = await openConfirm({
    title: 'Delete note',
    message: `Delete "${note.title}"? This cannot be undone.`,
  });
  if (!ok) return;

  state.notes = state.notes.filter(n => n.id !== note.id);
  delete state.positions[note.id];
  state.ui.activeNoteId = null;
  state.ui.creatingNew = false;

  await persistNotes(state.notes);
  await persistMeta();
  renderAll();
  showToast('Note deleted.');
}

function exportJson() {
  const payload = {
    schemaVersion: 1,
    exportedAt: nowIso(),
    notes: state.notes,
    graphPositions: state.positions,
  };
  const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  const d = new Date();
  const filename = `wiki-export-${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}.json`;
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

function resolveUniqueImportTitle(baseTitle, ownedById, currentId) {
  const base = (baseTitle || 'Untitled').trim() || 'Untitled';
  let candidate = base;
  let count = 1;
  while (true) {
    const key = normTitleKey(candidate);
    const owner = ownedById.get(key);
    if (!owner || owner === currentId) return candidate;
    candidate = `${base} (imported ${count})`;
    count += 1;
  }
}

async function importJsonFile(file) {
  let parsed;
  try {
    parsed = JSON.parse(await file.text());
  } catch {
    showToast('Invalid JSON file.');
    return;
  }

  if (!parsed || parsed.schemaVersion !== 1 || !Array.isArray(parsed.notes)) {
    showToast('Unsupported import format.');
    return;
  }

  const byId = new Map(state.notes.map(note => [note.id, { ...note }]));
  const ownedByTitle = new Map();
  byId.forEach(note => ownedByTitle.set(normTitleKey(note.title), note.id));

  parsed.notes.forEach((raw, i) => {
    const id = (raw && typeof raw.id === 'string' && raw.id.trim()) ? raw.id : uid() + '_' + i;

    const prev = byId.get(id);
    if (prev) {
      ownedByTitle.delete(normTitleKey(prev.title));
    }

    const cleanTitle = resolveUniqueImportTitle(typeof raw.title === 'string' ? raw.title : 'Untitled', ownedByTitle, id);
    const note = {
      id,
      title: cleanTitle,
      body: typeof raw.body === 'string' ? raw.body : '',
      tags: Array.isArray(raw.tags) ? [...new Set(raw.tags.map(t => String(t).trim().toLowerCase()).filter(Boolean))] : [],
      createdAt: typeof raw.createdAt === 'string' ? raw.createdAt : nowIso(),
      updatedAt: typeof raw.updatedAt === 'string' ? raw.updatedAt : nowIso(),
    };

    byId.set(id, note);
    ownedByTitle.set(normTitleKey(note.title), id);
  });

  state.notes = [...byId.values()];

  if (parsed.graphPositions && typeof parsed.graphPositions === 'object') {
    Object.keys(parsed.graphPositions).forEach(id => {
      const p = parsed.graphPositions[id];
      if (!p || typeof p.x !== 'number' || typeof p.y !== 'number') return;
      state.positions[id] = { x: Math.round(p.x), y: Math.round(p.y) };
    });
  }

  await persistNotes(state.notes);
  await persistMeta();
  renderAll();
  showToast(`Imported ${parsed.notes.length} notes.`);
}

function renderMobileTab() {
  const isMobile = window.matchMedia('(max-width: 860px)').matches;
  if (!isMobile) {
    document.querySelectorAll('.wk-panel[data-pane]').forEach(panel => panel.classList.add('active'));
    return;
  }

  const tab = state.ui.mobileTab || 'list';
  document.querySelectorAll('.wk-panel[data-pane]').forEach(panel => {
    panel.classList.toggle('active', panel.getAttribute('data-pane') === tab);
  });
  el.mobileTabs.querySelectorAll('button').forEach(button => {
    button.classList.toggle('active', button.getAttribute('data-tab') === tab);
  });
}

function focusPane(tabName) {
  if (!window.matchMedia('(max-width: 860px)').matches) return;
  state.ui.mobileTab = tabName;
  persistMeta().catch(() => {});
  renderMobileTab();
}

function bindPreviewInteractions() {
  el.preview.addEventListener('click', async (e) => {
    const target = e.target;
    if (!(target instanceof HTMLElement)) return;
    const title = target.getAttribute('data-open-title');
    if (!title) return;

    const key = normTitleKey(title);
    const note = state.notes.find(n => normTitleKey(n.title) === key);
    if (!note) {
      showToast(`No note titled "${title}".`);
      return;
    }

    state.ui.activeNoteId = note.id;
    state.ui.creatingNew = false;
    await persistMeta();
    renderAll();
  });
}

function bindEvents() {
  el.search.addEventListener('input', async () => {
    state.ui.query = el.search.value;
    await persistMeta();
    renderAll();
  });

  el.clearSearchBtn.addEventListener('click', async () => {
    state.ui.query = '';
    el.search.value = '';
    await persistMeta();
    renderAll();
  });

  el.clearTagsBtn.addEventListener('click', async () => {
    state.ui.selectedTags = [];
    await persistMeta();
    renderAll();
  });

  el.unlinkedOnly.addEventListener('change', async () => {
    state.ui.unlinkedOnly = el.unlinkedOnly.checked;
    await persistMeta();
    renderAll();
  });

  el.newNoteBtn.addEventListener('click', createNewNote);
  el.saveBtn.addEventListener('click', saveCurrentNote);
  el.deleteBtn.addEventListener('click', deleteActiveNote);

  el.noteForm.addEventListener('submit', (e) => {
    e.preventDefault();
    saveCurrentNote();
  });

  el.inputBody.addEventListener('input', () => {
    renderPreview(el.inputBody.value);
  });

  el.inputTitle.addEventListener('keydown', (e) => {
    if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 's') {
      e.preventDefault();
      saveCurrentNote();
    }
  });

  el.resetLayoutBtn.addEventListener('click', async () => {
    state.positions = {};
    ensurePositions(state.notes);
    await persistMeta();
    renderAll();
    showToast('Layout reset.');
  });

  el.fitGraphBtn.addEventListener('click', () => {
    if (state.cache.model) focusGraphToVisible(state.cache.model);
  });

  el.exportBtn.addEventListener('click', exportJson);
  el.importInput.addEventListener('change', async () => {
    const file = el.importInput.files && el.importInput.files[0];
    if (!file) return;
    await importJsonFile(file);
    el.importInput.value = '';
  });

  el.dashboardBtn.addEventListener('click', () => AppNav.goDashboard());

  el.mobileTabs.addEventListener('click', async (e) => {
    const t = e.target;
    if (!(t instanceof HTMLElement)) return;
    const tab = t.getAttribute('data-tab');
    if (!tab) return;
    state.ui.mobileTab = tab;
    await persistMeta();
    renderMobileTab();
  });

  window.addEventListener('resize', renderMobileTab);
}

async function init() {
  Theme.init({ defaultMode: 'dark' });
  Theme.mountToggle(el.themeToggle);

  state.db = await dbOpen();
  state.notes = await readAllNotes(state.db);
  state.ui = { ...DEFAULT_UI, ...(await readMeta(state.db, META_UI_KEY) || {}) };
  state.positions = (await readMeta(state.db, META_POSITIONS_KEY)) || {};

  ensurePositions(state.notes);
  el.search.value = state.ui.query || '';
  el.unlinkedOnly.checked = !!state.ui.unlinkedOnly;

  bindEvents();
  bindPreviewInteractions();
  setupGraphPanAndZoom();
  renderAll();
}

init().catch((error) => {
  console.error(error);
  showToast('Failed to initialize app.');
});
  </script>
</body>

</html>
